
1. What is the purpose of having an individual handler function for each exception/interrupt? 

Answer: Different handler has different stack layout, some of them need error code, some don't.

2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault(trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler?

Answer: General protection fault will arise when you're trying to access an entry in IDT with wrong authority. The program user/softint will run under user mode, and int $14 instruction will access the 14th entry in IDT, which could only be accessed under kernel mode. So general protection will show up. 
If you simply open the authority of page fault to user, as int won't push error code in the stack, which is used by the page fault handler inside CPU, so there'll still be problem.

3. The breakpoint tet case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT. Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

Answer: If we set the breakpoint gate with dpl=3, it could be accessed in user-mode. If dpl=0, then it could only be accessed in kernel mode and a general protection fault will be returned to user mode program.

4. What do you think is the point of these mechanisms, particularly in light of what the user/softint program does?

Answer: All about protection in the IDT.

